{% extends '@Synapse/admin/layout.html.twig' %}

{% block admin_title %}
	Embeddings — Synapse Admin
{% endblock %}

{% block admin_content %}
	<div class="synapse-admin__page">
		<div class="synapse-admin__page-header">
			<div>
				<h1 class="synapse-admin__page-title">
					<i><i data-lucide="database"></i></i>
					Embeddings & RAG
				</h1>
				<p class="synapse-admin__page-subtitle">
					Configurez le moteur de vectorisation global. Ces réglages assurent la cohérence de votre base de connaissances sémantique.
				</p>
			</div>
			<div class="synapse-admin__header-actions">
				{% if config.embeddingProvider and config.embeddingModel %}
					<span class="synapse-admin__badge synapse-admin__badge--success">
						<i data-lucide="check-circle"></i> API Connectée
					</span>
				{% else %}
					<span class="synapse-admin__badge synapse-admin__badge--warning">
						<i data-lucide="alert-triangle"></i> Non configuré
					</span>
				{% endif %}
			</div>
		</div>

		<div class="synapse-admin__grid" style="grid-template-columns: 1.8fr 1.2fr;">

			{# Colonne Gauche : Configuration #}
			<div style="display: flex; flex-direction: column; gap: 2rem;">
				<form method="post" action="{{ path('synapse_admin_embeddings') }}">
					<div class="synapse-admin__card">
						<div class="synapse-admin__card-header">
							<span class="synapse-admin__card-title">Moteur de Vectorisation</span>
							<p class="synapse-admin__card-subtitle">Source de vérité pour la génération d'embeddings.</p>
						</div>
						<div class="synapse-admin__card-body">
							<div class="synapse-admin__form-row">
								<label class="synapse-admin__label">Provider d'Embedding Actif</label>
								<select name="embedding_provider" class="synapse-admin__select" id="embedding_provider_select">
									<option value="">-- Résolution automatique (par défaut) --</option>
									{% for provider in active_providers %}
										<option value="{{ provider.name }}" {% if config.embeddingProvider == provider.name %} selected {% endif %}>
											{{ provider.label }}
										</option>
									{% endfor %}
								</select>
								<p class="synapse-admin__help">Sélectionnez le fournisseur que vous souhaitez utiliser. Seuls les fournisseurs activés sont listés.</p>
							</div>

							<div class="synapse-admin__form-row" id="embedding_model_row" style="display: none;">
								<label class="synapse-admin__label">Modèle d'embedding actif</label>
								<select name="embedding_model" class="synapse-admin__select" id="embedding_model_select">
									<option value="">-- Résolution automatique (par défaut) --</option>
								</select>
							</div>

							<div class="synapse-admin__form-row" id="embedding_dimension_row" style="display: none;">
								<label class="synapse-admin__label">Dimension des vecteurs (Output Dimensionality)</label>
								<select name="embedding_dimension" class="synapse-admin__select" id="embedding_dimension_select">
									<option value="">-- Par défaut --</option>
								</select>
								<p class="synapse-admin__help">Certains modèles (ex: Vertex AI, Nomic) permettent de réduire la taille des vecteurs générés pour économiser du stockage au prix d'une légère baisse de précision.</p>
							</div>
						</div>
					</div>

					<div class="synapse-admin__card">
						<div class="synapse-admin__card-header">
							<span class="synapse-admin__card-title">Stockage des Vecteurs</span>
							<p class="synapse-admin__card-subtitle">Où les dimensions numériques sont-elles conservées ?</p>
						</div>
						<div class="synapse-admin__card-body">
							<div class="synapse-admin__form-row">
								<label class="synapse-admin__label">Moteur de stockage (Vector Store)</label>
								<select name="vector_store" class="synapse-admin__select">
									{% for store in available_vector_stores %}
										<option value="{{ store }}" {% if config.vectorStore == store %} selected {% endif %}>
											{{ store|capitalize }}
										</option>
									{% endfor %}
								</select>
								<p class="synapse-admin__help">
									<strong>Doctrine</strong> : Utilise votre base actuelle (PostgreSQL idéalement).<br>
									<strong>InMemory</strong> : Rapide mais s'efface au redémarrage (tests uniquement).
								</p>
							</div>
						</div>
					</div>

					<div class="synapse-admin__card">
						<div class="synapse-admin__card-header">
							<span class="synapse-admin__card-title">Chunking et Stratégies d'Indexation</span>
						</div>
						<div class="synapse-admin__card-body">
							<div class="synapse-admin__form-row">
								<label class="synapse-admin__label">Stratégie de découpage</label>
								<select name="chunking_strategy" class="synapse-admin__select" id="chunking_strategy_select">
									<option value="recursive" {% if config.chunkingStrategy == 'recursive' %} selected {% endif %}>Récursive (Recommandé)</option>
									<option value="fixed" {% if config.chunkingStrategy == 'fixed' %} selected {% endif %}>Taille fixe</option>
								</select>
								<p class="synapse-admin__help">La stratégie récursive préserve la structure sémantique (paragraphes/phrases).</p>
							</div>

							<div class="synapse-admin__grid" style="grid-template-columns: 1fr 1fr; gap: 1.5rem; margin-top: 1.5rem;">
								<div class="synapse-admin__form-row">
									<label class="synapse-admin__label">Taille des chunks</label>
									<input type="number" name="chunk_size" class="synapse-admin__input" value="{{ config.chunkSize|default(1000) }}" step="100" min="100" max="20000" id="chunk_size_input" required>
									<p class="synapse-admin__help">Nombre max de caractères (100 - 20 000).</p>
								</div>
								<div class="synapse-admin__form-row">
									<label class="synapse-admin__label">Overlap</label>
									<input type="number" name="chunk_overlap" class="synapse-admin__input" value="{{ config.chunkOverlap|default(200) }}" step="50" min="0" max="10000" id="chunk_overlap_input" required>
									<p class="synapse-admin__help">Recouvrement de contexte.</p>
								</div>
							</div>

							{# Visualiseur de Chunking #}
							<div class="synapse-admin__chunk-viz" style="margin-top: 2rem; padding: 1.5rem; background: var(--synapse-admin-bg-main); border-radius: var(--synapse-admin-radius); border: 1px dashed var(--synapse-admin-border);">
								<div style="font-size: 0.75rem; font-weight: 700; text-transform: uppercase; color: var(--synapse-admin-text-muted); margin-bottom: 1rem; display: flex; justify-content: space-between;">
									<span>Aperçu visuel du découpage</span>
									<span id="viz_info">Taille: 1000 | Overlap: 200</span>
								</div>
								<div id="chunk_visual_track" style="height: 12px; background: white; border-radius: 6px; position: relative; overflow: hidden; display: flex; gap: 4px;">
									{# Les morceaux seront générés en JS #}
								</div>
							</div>
						</div>
					</div>

					<div class="synapse-admin__form-actions">
						<button type="submit" class="synapse-admin__btn synapse-admin__btn--primary">
							<i data-lucide="save"></i>
							Enregistrer la configuration globale
						</button>
					</div>
				</form>
			</div>

			{# Colonne Droite : Widgets de Test & DB #}
			<div
				style="display: flex; flex-direction: column; gap: 1.5rem;">

				{# Widget de Test #}
				<div class="synapse-admin__card">
					<div class="synapse-admin__card-header">
						<span class="synapse-admin__card-title">Test d'Embedding</span>
					</div>
					<div class="synapse-admin__card-body">
						{% if config.embeddingModel or config.embeddingProvider %}
							<p class="synapse-admin__help mb-4">Générez un vecteur pour vérifier la bonne communication avec l'API configurée (paramètres sauvegardés).</p>

							<div class="synapse-admin__form-row" style="margin-bottom: 1rem;">
								<textarea id="test_embedding_text" class="synapse-admin__input" rows="2" placeholder="Texte à vectoriser..." style="resize: vertical; font-size: 0.9rem;">Bonjour Synapse !</textarea>
							</div>

							<button type="button" class="synapse-admin__btn synapse-admin__btn--secondary" id="test_embedding_btn" style="width: 100%; justify-content: center;">
								<i data-lucide="flask-conical"></i>
								Tester l'API
							</button>

							<div id="test_embedding_result" style="margin-top: 1rem; display: none; background: var(--synapse-admin-bg); padding: 1rem; border-radius: var(--synapse-admin-radius); border: 1px solid var(--synapse-admin-border-light);">
								<div id="test_embedding_status" style="font-weight: 600; margin-bottom: 0.5rem; display: flex; align-items: center; gap: 0.5rem;"></div>

								{# Visualization Visual #}
								<div id="test_embedding_viz" style="margin-bottom: 1rem; height: 40px; background: var(--synapse-admin-bg-hover); border-radius: 4px; overflow: hidden; display: flex; align-items: stretch; border: 1px solid var(--synapse-admin-border-light);"></div>

								<div id="test_embedding_details" style="font-size: 0.85rem; color: var(--synapse-admin-text-secondary); margin-bottom: 0.5rem;"></div>
								<pre id="test_embedding_json" style="margin: 0; padding: 0.5rem; background: var(--synapse-admin-bg-hover); border-radius: 4px; font-size: 0.75rem; overflow-x: auto; color: var(--synapse-admin-text); max-height: 100px;"></pre>
							</div>
						{% else %}
							<div class="synapse-admin__alert synapse-admin__alert--warning" style="margin: 0; padding: 1rem;">
								Veuillez enregistrer une configuration avant de pouvoir tester.
							</div>
						{% endif %}
					</div>
				</div>

				{# Widget Base de données #}
				<div class="synapse-admin__card">
					<div class="synapse-admin__card-header" style="background: linear-gradient(135deg, var(--synapse-admin-bg-card) 0%, rgba(139, 92, 246, 0.05) 100%);">
						<span class="synapse-admin__card-title">Infrastructure Vectorielle</span>
					</div>
					<div class="synapse-admin__card-body" style="padding: 1.5rem;">
						{% if db_vector_ready %}
							<div class="synapse-admin__badge synapse-admin__badge--success" style="margin-bottom: 1rem; width: 100%;">
								<i data-lucide="check-circle"></i> Support Natif Actif
							</div>
							<p class="synapse-admin__text-muted" style="font-size: 0.85rem;">
								Votre base PostgreSQL utilise l'extension <code>pgvector</code>. Les recherches sémantiques sont optimisées.
							</p>
						{% elseif db_is_postgres %}
							<div class="synapse-admin__badge synapse-admin__badge--warning" style="margin-bottom: 1rem; width: 100%;">
								<i data-lucide="alert-triangle"></i> Extension Manquante
							</div>
							<p class="synapse-admin__text-muted" style="font-size: 0.85rem; margin-bottom: 1rem;">
								PostgreSQL détecté mais sans <code>pgvector</code>. Activez-le pour de meilleures performances :
							</p>
							<div style="background: var(--synapse-admin-bg-sidebar); border-radius: 6px; padding: 0.75rem; display: flex; align-items: center; justify-content: space-between; gap: 0.5rem;">
								<code style="color: var(--synapse-admin-primary-light); font-size: 0.8rem;">CREATE EXTENSION vector;</code>
								<button class="synapse-admin__btn synapse-admin__btn--ghost synapse-admin__btn--sm" style="padding: 4px 8px; border-color: rgba(255,255,255,0.2); color: white;" onclick="navigator.clipboard.writeText('CREATE EXTENSION vector;'); this.innerHTML='<i data-lucide=\'check\'></i>'">
									<i data-lucide="copy" style="width: 14px;"></i>
								</button>
							</div>
						{% else %}
							<div class="synapse-admin__badge synapse-admin__badge--muted" style="margin-bottom: 1rem; width: 100%;">
								<i data-lucide="info"></i> Support natif indisponible
							</div>
							<p class="synapse-admin__text-muted" style="font-size: 0.85rem;">
								La plateforme <strong>{{ db_platform }}</strong> ne supporte pas nativement les vecteurs. Un moteur tiers sera nécessaire pour le RAG à grande échelle.
							</p>
						{% endif %}
					</div>
				</div>

			</div>
		</div>
	</div>

	<script>
		document.addEventListener('DOMContentLoaded', function () { // Configuration Dynamique Provider/Model/Dimensions
const providerSelect = document.getElementById('embedding_provider_select');
const modelRow = document.getElementById('embedding_model_row');
const modelSelect = document.getElementById('embedding_model_select');
const dimensionRow = document.getElementById('embedding_dimension_row');
const dimensionSelect = document.getElementById('embedding_dimension_select');

const modelsByProvider = {{ embedding_models_by_provider|json_encode|raw }};

const currentSavedModel = "{{ config.embeddingModel|default('') }}";
const currentSavedDimension = "{{ config.embeddingDimension|default('') }}";

function updateModels() {
const provider = providerSelect.value;

if (! provider || ! modelsByProvider[provider] || Object.keys(modelsByProvider[provider]).length === 0) {
modelRow.style.display = 'none';
modelSelect.innerHTML = '<option value="">-- Résolution automatique (par défaut) --</option>';
updateDimensions();
return;
}

modelRow.style.display = 'block';
let html = '<option value="">-- Résolution automatique (par défaut) --</option>';

const models = modelsByProvider[provider];
for (const modelId in models) {
const caps = models[modelId];
const isSelected = (currentSavedModel == modelId) ? 'selected' : '';
const dimensionsData = caps.dimensions ? JSON.stringify(caps.dimensions) : '';

html += `<option value="${modelId}" ${isSelected} data-dimensions='${dimensionsData}'>${modelId}</option>`;
}

modelSelect.innerHTML = html;
updateDimensions();
}

function updateDimensions() {
const selectedOption = modelSelect.options[modelSelect.selectedIndex];
if (! selectedOption || ! selectedOption.dataset.dimensions) {
dimensionRow.style.display = 'none';
dimensionSelect.innerHTML = '<option value="">-- Par défaut --</option>';
return;
}

try {
const dimensions = JSON.parse(selectedOption.dataset.dimensions);
if (dimensions && dimensions.length > 1) {
dimensionRow.style.display = 'block';
dimensionSelect.innerHTML = '';
let html = `<option value="">-- Par défaut (${dimensions[0]}) --</option>`;
dimensions.forEach(dim => {
const isSelected = (currentSavedDimension == dim) ? 'selected' : '';
html += `<option value="${dim}" ${isSelected}>${dim} dimensions</option>`;
});
dimensionSelect.innerHTML = html;
} else {
dimensionRow.style.display = 'none';
dimensionSelect.innerHTML = '<option value="">-- Par défaut --</option>';
}
} catch (e) {
dimensionRow.style.display = 'none';
}
}

// Visualiseur de Chunking
const chunkSizeInput = document.getElementById('chunk_size_input');
const chunkOverlapInput = document.getElementById('chunk_overlap_input');
const strategySelect = document.getElementById('chunking_strategy_select');
const chunkVisualTrack = document.getElementById('chunk_visual_track');
const vizInfo = document.getElementById('viz_info');

function updateChunkViz() {
const size = parseInt(chunkSizeInput.value) || 1000;
const overlap = parseInt(chunkOverlapInput.value) || 0;
const strategy = strategySelect.value;

vizInfo.textContent = `Taille: ${size} | Overlap: ${overlap} | ${strategy == 'recursive' ? 'Récursif' : 'Fixe'}`;

chunkVisualTrack.innerHTML = '';
const totalWidth = chunkVisualTrack.offsetWidth || 500;

// Échelle adaptative : on simule une longueur de texte qui dépend de la taille du chunk
// pour que le visualiseur reste lisible quelle que soit la taille.
// On affiche environ 3 chunks complets.
const simulatedChars = Math.max(3000, size * 3.5);
const charToPx = totalWidth / simulatedChars;

let currentPos = 0;
let step = size - overlap;

// Sécurité : éviter boucle infinie
if (step <= 0) 
step = size / 2;


const colors = strategy === 'recursive' 
? ['#8b5cf6', '#a78bfa', '#c4b5fd', '#ddd6fe'] // Violet pour récursif
: ['#3b82f6', '#60a5fa', '#93c5fd', '#bfdbfe']; // Bleu pour fixe

for (let i = 0; i < 10; i++) {
const chunk = document.createElement('div');
chunk.style.position = 'absolute';
chunk.style.left = (currentPos * charToPx) + 'px';
chunk.style.width = (size * charToPx) + 'px';
chunk.style.height = '100%';

const colorBase = colors[i % colors.length];
chunk.style.backgroundColor = colorBase + '4d'; // 30% alpha
chunk.style.border = `1px solid ${colorBase}80`; // 50% alpha
chunk.style.borderRadius = '4px';
chunk.style.zIndex = i;
chunkVisualTrack.appendChild(chunk);

currentPos += step;
if (currentPos * charToPx > totalWidth) 
break;

}
}

if (providerSelect) {
providerSelect.addEventListener('change', updateModels);
modelSelect.addEventListener('change', updateDimensions);
chunkSizeInput.addEventListener('input', updateChunkViz);
chunkOverlapInput.addEventListener('input', updateChunkViz);
strategySelect.addEventListener('change', updateChunkViz);
updateModels();
setTimeout(updateChunkViz, 100);
}

// Script de Test d'Embedding AJAX
const testBtn = document.getElementById('test_embedding_btn');
const testText = document.getElementById('test_embedding_text');
const testResult = document.getElementById('test_embedding_result');
const testStatus = document.getElementById('test_embedding_status');
const testDetails = document.getElementById('test_embedding_details');
const testJson = document.getElementById('test_embedding_json');

if (testBtn) {
testBtn.addEventListener('click', async () => {
const text = testText.value;
const originalText = testBtn.innerHTML;

testBtn.innerHTML = '<i data-lucide="loader-2" class="lucide-spin"></i> Génération en cours...';
testBtn.disabled = true;
testResult.style.display = 'none';
if (typeof lucide !== 'undefined') 
lucide.createIcons();



try {
const formData = new FormData();
formData.append('text', text);

const csrfMeta = document.querySelector('meta[name="csrf-token"]');
const csrfToken = csrfMeta ? csrfMeta.getAttribute('content') : '';

const response = await fetch('{{ path("synapse_admin_embeddings_test") }}', {
method: 'POST',
body: formData,
headers: {
'X-Requested-With': 'XMLHttpRequest',
'X-CSRF-Token': csrfToken
}
});


const isJson = response.headers.get('content-type') ?. includes('application/json');
if (! isJson) {
throw new Error('La réponse du serveur n\'est pas au format JSON.');
}

const data = await response.json();

testResult.style.display = 'block';

if (data.success) {
testStatus.innerHTML = '<i data-lucide="check-circle" style="color: var(--synapse-admin-success); width: 16px;"></i> <span style="color: var(--synapse-admin-success);">Succès de l\'API</span>';

// Visualization Rendering
const vizContainer = document.getElementById('test_embedding_viz');
vizContainer.innerHTML = '';
if (Array.isArray(data.sample)) {
const maxVal = Math.max(...data.sample.map(Math.abs)) || 1;
data.sample.forEach(val => {
const slice = document.createElement('div');
slice.style.flex = '1';
const intensity = (Math.abs(val) / maxVal);
slice.style.backgroundColor = val > 0 ? `rgba(139, 92, 246, ${0.2 + intensity * 0.8})` : `rgba(236, 72, 153, ${0.2 + intensity * 0.8})`;
slice.style.height = (20 + intensity * 80) + '%';
slice.style.alignSelf = 'center';
slice.title = val.toFixed(4);
vizContainer.appendChild(slice);
});
}

let detailsHtml = `<strong>Dimension:</strong> ${
data.dimension
} vecteurs<br>`;
detailsHtml += `<strong>Temps de réponse:</strong> ${
data.time
} ms`;
if (data.usage ?. prompt_tokens) {
detailsHtml += `<br><strong>Tokens consommés:</strong> ${
data.usage.prompt_tokens
}`;
}
testDetails.innerHTML = detailsHtml;

const sampleStr = Array.isArray(data.sample) ? data.sample.slice(0, 5).map(v => Number(v).toFixed(6)).join(', ') + (data.dimension > 5 ? ', ...' : '') : '';
testJson.textContent = `[${sampleStr}]`;
} else {
testStatus.innerHTML = '<i data-lucide="x-circle" style="color: var(--synapse-admin-error); width: 16px;"></i> <span style="color: var(--synapse-admin-error);">Erreur d\'API</span>';
testDetails.innerHTML = '';
testJson.textContent = data.error || 'Erreur inconnue';
}
} catch (err) {
testResult.style.display = 'block';
testStatus.innerHTML = '<i data-lucide="x-circle" style="color: var(--synapse-admin-error); width: 16px;"></i> <span style="color: var(--synapse-admin-error);">Erreur Serveur</span>';
testDetails.innerHTML = '';
testJson.textContent = err.message;
} finally {
testBtn.innerHTML = originalText;
testBtn.disabled = false;
if (typeof lucide !== 'undefined') 
lucide.createIcons();



}
});
}
});
	</script>
{% endblock %}
